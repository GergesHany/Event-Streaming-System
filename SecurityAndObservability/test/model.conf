# ---------------------- Request definition ----------------------

# What it means:
    # r: Represents a request tuple
    # sub: Subject - Who is making the request (user, service, role)
    # obj: Object - What resource is being accessed (topic, queue, API endpoint)
    # act: Action - What operation is being performed (produce, consume, read, write)

# Example in practice:
    # ("alice", "topic1", "produce") - Alice wants to produce messages to topic1
    # ("service-a", "queue2", "consume") - Service A wants to consume from queue2

[request_definition]
r = sub, obj, act



# ---------------------- Policy definition ----------------------

# What it means:
    # p: Represents a policy rule tuple
    # Has the same structure as requests: subject, object, action
    # These are the stored permission rules that define what's allowed

# Example policies (from your policy.csv):
    # ("root", "*", "produce") - Root user can produce to any resource
    # ("root", "*", "consume") - Root user can consume from any resource

[policy_definition]
p = sub, obj, act



# ---------------------- Policy effect ----------------------

# What it means:
    # e: Defines the effect calculation
    # some(where (p.eft == allow)): Access is granted if at least one matching policy has an "allow" effect
    # This is a permissive model - if any rule allows it, access is granted


[policy_effect]
e = some(where (p.eft == allow))


# ---------------------- Matchers ----------------------

# What it means:
    # m: Defines how to match requests against policies
    # r.sub == p.sub: Request subject must exactly match policy subject
    # r.obj == p.obj: Request object must exactly match policy object
    # r.act == p.act: Request action must exactly match policy action

[matchers]
m = r.sub == p.sub && r.obj == p.obj && r.act == p.act
